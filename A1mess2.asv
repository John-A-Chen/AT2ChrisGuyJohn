clf;
axis equal;
hold on;
view(3);
axis([-5 4 -3 3 0 3]);
xlim([-5 4]); ylim([-3 3]); zlim([0 3]);

r = KukaTitan(transl(-0.75,0.5,0.05));

PlaceObject('environment.PLY',[0,0,0]);

startPositions = ...
[-1.8, 3.5, 1.3;
 -1.4, 3.5, 1.3;
 -1.0, 3.5, 1.3;
 ];

endPositions = ...
[2,-2, 1.75;
 2,-2, 1.75;
 2,-2, 1.75;
];

hflange  = cell(1, size(startPositions, 1));
for i = 1:size(startPositions, 1)
    hflange{i} = PlaceObject('flange.ply', startPositions(i, :));
end

flangeOrigin = PlaceObject('flange0.ply', [0,0,0]);
vertices = get(flangeOrigin, 'Vertices'); 
delete(flangeOrigin);

numSteps = 50;
deltaT = 0.05; 
W = diag([1 1 1 0.1 0.1 0.1]); 
epsilon = 0.1; 

for i = 1:size(startPositions, 1)
    whereRobot = r.model.getpos();
    
    startTransform = transl(startPositions(i, :)) * trotx(pi);
    startJointAngles = r.model.ikcon(startTransform);

    for step = 1:numSteps
        T = r.model.fkine(whereRobot);
        deltaX = (startPositions(i, :)' - T(1:3,4)) / numSteps; 
        linear_velocity = deltaX / deltaT; 

        Rd = rpy2r(0, pi, 0); 
        Ra = T(1:3,1:3); 
        Rdot = (Rd - Ra) / deltaT; 
        angular_velocity = [Rdot(3,2); Rdot(1,3); Rdot(2,1)];

        xdot = W * [linear_velocity; angular_velocity]; 

        J = r.model.jacob0(whereRobot);

        manipulability = sqrt(det(J*J'));
        if manipulability < epsilon
            lambda = (1 - manipulability/epsilon) * 5E-2;
        else
            lambda = 0;
        end
        invJ = inv(J'*J + lambda * eye(6)) * J'; 
        qdot = invJ * xdot;
        whereRobot = whereRobot + deltaT * qdot'; 

        r.model.animate(whereRobot); 
        pause(0.05);
    end

    for step = 1:numSteps
        T = r.model.fkine(whereRobot);
        deltaX = (endPositions(i, :)' - T(1:3,4)) / numSteps; 
        linear_velocity = deltaX / deltaT; 

        Rd = rpy2r(0, pi, 0);
        Ra = T(1:3,1:3); 
        Rdot = (Rd - Ra) / deltaT; 
        angular_velocity = [Rdot(3,2); Rdot(1,3); Rdot(2,1)];

        xdot = W * [linear_velocity; angular_velocity]; 

        J = r.model.jacob0(whereRobot); 

        manipulability = sqrt(det(J*J'));
        if manipulability < epsilon
            lambda = (1 - manipulability/epsilon) * 5E-2;
        else
            lambda = 0;
        end
        invJ = inv(J'*J + lambda * eye(6)) * J'; % DLS inverse Jacobian
        qdot = invJ * xdot; % Joint velocity
        whereRobot = whereRobot + deltaT * qdot'; % Update joint state

        r.model.animate(whereRobot); % Animate robot movement
        
        % Move the flange along with the robot
        whereEndEffector = r.model.fkine(whereRobot);
        trVertices = [vertices, ones(size(vertices, 1), 1)] * whereEndEffector.T';
        set(hflange{i}, 'Vertices', trVertices(:, 1:3));
        drawnow();
        pause(0.05);
    end
    delete(hflange{i});
    PlaceObject('flange.ply', endPositions(i, :));
end
